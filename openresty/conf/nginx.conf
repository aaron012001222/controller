worker_processes  1;
events { worker_connections 1024; }

http {
    include       mime.types;
    default_type  application/octet-stream;
    
    # Lua 模块路径
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";

    # Docker DNS (用于解析容器名) 和 公网 DNS (用于 Let's Encrypt 验证)
    resolver 127.0.0.11 8.8.8.8 ipv6=off;

    # 1. 初始化 Auto-SSL (分配共享内存)
    lua_shared_dict auto_ssl 1m;
    lua_shared_dict auto_ssl_settings 64k;

    # 2. Auto-SSL 初始化逻辑
    init_by_lua_block {
        auto_ssl = (require "resty.auto-ssl").new()
        
        -- 定义存储适配器 (存入 Redis，这样重启容器证书不丢)
        auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapter.redis")
        auto_ssl:set("redis_host", "redis") -- 对应 docker-compose 中的服务名
        auto_ssl:set("redis_port", 6379)

        -- 【核心安全设置】: 必须检查域名是否在我们的 A池 中！
        auto_ssl:set("allow_domain", function(domain)
            local redis = require "resty.redis"
            local red = redis:new()
            red:set_timeout(1000)
            -- 连接 Redis
            local ok, err = red:connect("redis", 6379)
            if not ok then return false end
            
            -- 检查域名是否存在于我们的 Redis 数据库中 (key 格式 domain:example.com)
            local exists, err = red:exists("domain:" .. domain)
            
            -- 只有数据库里有的域名，才允许申请证书
            if exists == 1 then
                return true
            else
                return false
            end
        end)

        auto_ssl:init()
    }

    init_worker_by_lua_block {
        auto_ssl:init_worker()
    }

    # 3. 内部服务：用于处理 Let's Encrypt 的验证请求 (勿动)
    server {
        listen 127.0.0.1:8999;
        client_body_buffer_size 128k;
        client_max_body_size 128k;

        location / {
            content_by_lua_block {
                auto_ssl:hook_server()
            }
        }
    }

    # 4. 主服务 (合并了 SSL 申请和业务逻辑)
    server {
        # 监听端口
        listen 80;
        listen 443 ssl;
        server_name _; # 匹配所有域名

        # --- Auto-SSL 核心配置 ---
        # 动态证书挂载点
        ssl_certificate_by_lua_block {
            auto_ssl:ssl_certificate()
        }
        # 兜底证书 (首次握手需要的占位符，使用 install.sh 生成的自签名证书)
        ssl_certificate     /usr/local/openresty/nginx/certs/server.crt;
        ssl_certificate_key /usr/local/openresty/nginx/certs/server.key;
        # -----------------------

        # Let's Encrypt 验证专用接口
        location /.well-known/acme-challenge/ {
            content_by_lua_block {
                auto_ssl:challenge_server()
            }
        }

        # ==========================================
        # [模板占位符] 隐形入口 (install.sh 会替换这里)
        # ==========================================
        location = /SECRET_ENTRANCE_PLACEHOLDER {
            add_header Set-Cookie "admin_access=true; Path=/; Max-Age=2592000";
            return 302 /;
        }

        # ==========================================
        # 后端 API 转发
        # ==========================================
        location /api {
            proxy_pass http://backend:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_read_timeout 300s;
        }

        # ==========================================
        # 前端页面 (带门禁检查)
        # ==========================================
        location / {
            # 强制 HTTPS (可选，如果你希望 HTTP 也能访问则注释掉)
            if ($scheme = http) {
                return 301 https://$host$request_uri;
            }

            # Lua 流量控制逻辑
            access_by_lua_file /usr/local/openresty/nginx/lua/access.lua;
            
            root   /usr/share/nginx/html;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
    }
}